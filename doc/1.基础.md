# React 基础

先看看 react 主要的几个特点
> 1. 声明式：以声明式编写 UI，代码更加可靠，且方便调试
> 2. 组件化：构建管理自身状态的封装组件，然后对齐组合以构成复杂 UI。组件的逻辑使用 JavaScript 进行编写而不使用模板，可以轻松的传递数据，并保持 DOM 的分离。

**声明式编程和命令式编程**

> 命令式编程描述代码如何工作，而声明式编程则表明想要实现什么目的。

- **给我来杯啤酒**

命令式用生活中的一个例子来说，就好比当你去和服务员要一杯啤酒时对服务员做这样的指示：
1. 从架子拿一个玻璃杯
2. 将杯子放到酒桶前
3. 打开酒桶开关，将杯子装满
4. 把杯子递给我

如果用的是声明式，你只需要说：“请给我一杯啤酒”。使用这种方式来点啤酒，我们需要假设服务员知道如何提供啤酒。这是声明式编程工作的一个重要方面。

- **JavaScript 将数组元素大写字符串转成小写**

再看看一个 JavaScript 的例子，实现一个将数组中的元素的大写字符串转成小写字符串
```js
toLowerCase(['Foo', 'BAR']); // ['foo', 'bar']
```

解决这个问题，用命令式来实现就是：
```js
const toLowerCase = input => {
  const output = [];
  for (let i = 0; i < input.length; i++) {
    output.push(input[i].toLowerCase())
  }
  return output()
}
```

首先我们需要定一个数组，然后遍历输入数组的所有元素，把它们转为小写之后 `push` 新的数组中，最后将新的数组返回。

如果使用的是声明式：

```js
const toLowerCase = input => input.map(value => value.toLowerCase())
```
输入的数组的元素会传递到 `map` 中，然后 `map` 函数会返回小写值的数组。

相对于之前的方法来说，这个更加的优雅、简洁和易读。**另外，声明式编程无需使用变量，也不用在执行过程中持续更新变量的值。事实上，声明式编程往往避免了创建和修改状态。**

- **在 React 的 UI 中**

在开发中实现一个这样的需求，展示带有标记的地图。使用 JavaScript 的实现如下：
```js
const map = new google.maps.Map(document.getElementById('map'), {   
  zoom: 4,    
  center: myLatLng, 
}) 
const marker = new google.maps.Marker({   
  position: myLatLng,   
  title: 'Hello World!', 
}) 

marker.setMap(map)
```
这显然是编程式的，在代码中我们逐条描述了创建地图、创建标志、以及在地图上添加标志的指令。

改用 React 组件，那么方式就是：

```js
<Gmaps zoom={4} center={myLatLng}>
  <Marker position={myLatlng} title="Hello World!" />
</Gmaps>
```
使用声明式，我们只需要描述我们想要的功能，无须列出实现效果的所有步骤。

声明式的 UI 使得 React 很容易使用，最终的代码也比较简单，这样产生的 bug 更少。

## 1. JSX 语法

所谓的 JSX，就是 JavaScript 的语法扩展(eXtension)。它看起来和 HTML 比较类似，但它并不局限于 HTML 中的元素
- 它的元素可以是任何一个 React 组件。React 判断一个元素是 HTML 元素还是 React 组件的原则就是看第一个字母是否是大写。
- 在 JSX 可以通过 onClick 这样的方式给一个元素添加一个事件处理函数。当然在 HTML 中也可以用 onclick，但在 HTML 中直接写 onclick 一直就是为人诟病的，会容易让人混乱，比较倡导使用 jQuery 的方法来添加处理函数。

使用的是 JSX 语法，最后经过 babel 编译成 JavaScript 来执行。

### 为什么使用 JSX

既然不推荐在 HTML 直接使用 onclick，那为什么 JSX 中我们缺使用这样的方式来添加事件处理函数呢？

以前我们
- 用 HTML 来代表内容
- 用 CSS 来代表样式
- 用 JavaScript 来定义交互行为

然后将这三种语言分在不同的文件中，实际上是“把技术分开管理，而不是分而治之”。

React 认为**渲染逻辑本质和其他的 UI 逻辑有内在耦合**，比如 UI 中需要绑定事件，在某些状态更新需要通知 UI。React 没有将标记（HTML）与逻辑进行分离到不同文件中这种人为的分离方式，**而是通过将两者放在称为“组件”的松散耦合单元中，来实现关注点的分离**。

做同一件事的代码应该高耦合，应该把实现这个功能的所有代码集中在一个文件里。除了在组件中定义交互行为，还可以在 React 组件中定义样式。

通过 React 组件可以把 JavaScript、HTML 和 CSS 的功能都写在一个文件中，实现了真正的组件封装。

```js
class List extends React.Component {
  render() {
    const listStyle = {
      margin: '16px'
    }
    return (
      <div className="list">
        <h1>List for {this.props.name}</h1>
        <ul onClick={this.Click} style={listStyle}>
          <li>1</li>
          <li>2</li>
        <ul>
      </div>
    )
  }
}
```
会被编译成
```js
return React.createElement('div', {className: 'list'},
  React.createElement('h1', /*... h1 children */),
  React.createElement('ul', /*... ul children */),
)
```
最后会创建这样的对象，它们就是“react 的元素”，描述你所在页面上看到的内容。react 通过读取这些对象，用来创建最后的 DOM，并保持随时更新。

```js
{
  type: 'div',
  props: {
    className: 'list',
    children: [
      //...
    ]
  }

}
```



## 2. 组件

React 的组件使用的是一个名为 `render()` 方法。
- 可以**向组件传递参数**，组件内部可以通过  `this.props` 获取。
- 组件内部也可以维护自己的状态，可以通过 `this.state` 访问，当组件的数据变化时，组件**会再次调用** `render()` 方法重新渲染更新


``` js
import React, { Component } from 'react';

class TodoApp extends Component {
  constructor(props) {
    super(props);
    // 定义自己的状态
    this.state = { items: [], text: '' };
    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  render() {
    return (
      <div>
        <h3>TODO</h3>
        <TodoList items={this.state.items} />
        <form onSubmit={this.handleSubmit}>
          <label htmlFor="new-todo">
            What needs to be done?
          </label>
          <input
            id="new-todo"
            onChange={this.handleChange}
            value={this.state.text}
          />
          <button>
            Add #{this.state.items.length + 1}
          </button>
        </form>
      </div>
    );
  }

  handleChange(e) {
    // 更新 state，重新进行渲染
    this.setState({ text: e.target.value });
  }

  handleSubmit(e) {
    e.preventDefault();
    if (this.state.text.length === 0) {
      return;
    }
    const newItem = {
      text: this.state.text,
      id: Date.now()
    };
    this.setState(state => ({
      items: state.items.concat(newItem),
      text: ''
    }));
  }
}

class TodoList extends React.Component {
  render() {
    return (
      <ul>
        {this.props.items.map(item => (
          <li key={item.id}>{item.text}</li>
        ))}
      </ul>
    );
  }
}

ReactDOM.render(
  <TodoApp />,
  document.getElementById('todos-example')
);
```

这里还有记得需要了解的，

- `import` 了  `Component`，`Component` 作为所有组件的基类，提供了很多组件共有的功能。可以通过 `extents Component` 来创建组件类
- 另外我们有必要 `import React`，看起来没有被用到？事实上这很有必要，在使用 JSX 的代码文件中，即使我们用不到 `React`，也需要将它倒入，因为 JSX 最后会被编译成依赖于 `React` 的表达式。例如前面看到的`React.createElement`

## 3. 组件通信
## 4. 组件生命周期